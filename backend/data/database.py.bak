import pyodbc
import pandas as pd
import logging
from typing import List, Dict, Any, Optional, Tuple
from core.config import get_db_connection_string
import time
import random

# Configure logger
logger = logging.getLogger(__name__)

class DatabaseManager:
    """
    Class to handle database connections and operations.
    """
    
    @staticmethod
    def get_connection():
        """
        Create and return a new connection to the database.
        """
        # Simulation mode - return None as we won't actually connect to a database
        return None
    
    @staticmethod
    def execute_stored_procedure(stored_proc_name: str, params: Dict[str, Any]) -> Tuple[pd.DataFrame, Optional[str]]:
        """
        Execute a stored procedure with the given parameters and return the results as a DataFrame.
        
        Args:
            stored_proc_name: Name of the stored procedure to execute
            params: Dictionary of parameter names and values
            
        Returns:
            Tuple containing DataFrame with results and optional error message
        """
        # Simulation mode - we'll generate fake data based on the stored procedure name
        logger.info(f"Executing simulated stored procedure: {stored_proc_name} with params: {params}")
        
        try:
            # Simulate processing time
            time.sleep(0.5)
            
            # Simulated data based on procedure name
            if stored_proc_name.lower() == "will_obtenerdatosparainforme2024v3":
                # Simulated data for "Informe de Altas Diarias"
                data = {
                    "Fecha": [f"2025-{random.randint(1, 8):02d}-{random.randint(1, 28):02d}" for _ in range(10)],
                    "NumeroCliente": [f"C{random.randint(10000, 99999)}" for _ in range(10)],
                    "NombreCliente": [f"Cliente {i}" for i in range(1, 11)],
                    "TipoAlta": ["Nueva", "Renovación", "Modificación"] * 3 + ["Nueva"],
                    "Operador": [f"OP{random.randint(100, 999)}" for _ in range(10)],
                    "Monto": [round(random.uniform(1000, 50000), 2) for _ in range(10)]
                }
            elif stored_proc_name.lower() == "will_obtenermovimientos_por_operador":
                # Simulated data for "Informe de Operadores"
                data = {
                    "Fecha": [f"2025-{random.randint(1, 8):02d}-{random.randint(1, 28):02d}" for _ in range(10)],
                    "CodigoOperador": [f"OP{random.randint(100, 999)}" for _ in range(10)],
                    "NombreOperador": [f"Operador {i}" for i in range(1, 11)],
                    "Letra": ["E", "K", "V"] * 3 + ["E"],
                    "CantidadMovimientos": [random.randint(5, 100) for _ in range(10)],
                    "MontoTotal": [round(random.uniform(5000, 100000), 2) for _ in range(10)]
                }
            else:
                # Generic simulated data for any other procedure
                data = {
                    "ID": list(range(1, 11)),
                    "Nombre": [f"Item {i}" for i in range(1, 11)],
                    "Valor1": [round(random.uniform(1, 100), 2) for _ in range(10)],
                    "Valor2": [round(random.uniform(100, 1000), 2) for _ in range(10)],
                    "Categoria": ["A", "B", "C"] * 3 + ["D"],
                    "Fecha": [f"2025-{random.randint(1, 12):02d}-{random.randint(1, 28):02d}" for _ in range(10)]
                }
            
            # Create a DataFrame from the simulated data
            df = pd.DataFrame(data)
            
            # Apply any filters from parameters
            for param_name, param_value in params.items():
                if param_name in df.columns and param_value:
                    if isinstance(param_value, str) and param_value.strip():
                        # String filtering - case insensitive partial match
                        df = df[df[param_name].astype(str).str.lower().str.contains(param_value.lower())]
                    elif isinstance(param_value, (int, float)):
                        # Numeric filtering - exact match
                        df = df[df[param_name] == param_value]
            
            # Ensure we return a proper DataFrame, not a filtered Series
            if isinstance(df, pd.Series):
                df = pd.DataFrame([df])
                
            return df, None
        
        except Exception as e:
            logger.error(f"Error simulating stored procedure execution: {e}")
            # Always return a DataFrame, even if empty
            return pd.DataFrame(), str(e)

    @staticmethod
    def get_operators_list() -> List[Dict[str, str]]:
        """
        Simulated method to get a list of operators for dropdown selection.
        """
        operators = []
        for i in range(1, 11):
            code = f"OP{random.randint(100, 999)}"
            name = f"Operador {i}"
            operators.append({"value": code, "label": f"{code} - {name}"})
        
        return operators
            
            sql_command = f"EXEC {stored_proc_name} {', '.join(param_placeholders)}"
            
            # Execute the stored procedure and return results as DataFrame
            df = pd.read_sql(sql_command, connection, params=sql_params)
            return df, None
            
        except Exception as e:
            error_message = f"Error executing stored procedure {stored_proc_name}: {str(e)}"
            logger.error(error_message)
            return pd.DataFrame(), error_message
        finally:
            if connection:
                connection.close()
                
    @staticmethod
    def get_operators_list() -> List[Dict[str, Any]]:
        """
        Fetch the list of operators from the database.
        This is an example of a method to get data for a select dropdown.
        
        Returns:
            List of dictionaries with operator information
        """
        connection = None
        try:
            connection = DatabaseManager.get_connection()
            
            # Example query - modify as needed to match your database schema
            query = """
            SELECT OperatorID as value, OperatorName as label
            FROM Operators
            ORDER BY OperatorName
            """
            
            df = pd.read_sql(query, connection)
            return df.to_dict('records')
            
        except Exception as e:
            logger.error(f"Error fetching operators list: {e}")
            return []
        finally:
            if connection:
                connection.close()
